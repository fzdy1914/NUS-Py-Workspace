def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)


def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

n = 19252920125214919393695663631622102766815853470967360059547775460809407621910413551654318709633811799718183394953496166912016383084714805258254092719872936429909416039285418340259476888010009116217034405561140592414796461670834124000401373748151261821083062388876669770157692860132185532147299927899226737494068818342352886069819327352796136008195293304696885024777584557724409338528622665479058261823015404741948116169018639408548212859316289267184761262236406750615698437954538040867234585263704806770724530346266059488761391922903299243494323854523084519586670548509178318433937012304458347680297617190215942405071
p = 122189541510705594361455588882218455099403439051272065174052908513549704243198036503131795156902801764500541392915781800816188825133573948972241849902315021881996969047188965457375551764841087305190852303686495149674078647718718197904703071128387812554667701333109827600037062401682351173931589381624650941467
q = 157566023140598178484896720342543298271189383626600767692362250444483090879673603394753504127114594597099937860317907337825437052007527663887384815806794238923218045251473655281364906521303351923622098375825008755133405093523621747796866368253141868878034174878079651143546186529618340613810967669621169298013

e = 31337

r = (p - 1) * (q - 1)

d = modinv(e, r)

c = 4817311251953964954683741959994023230807956934322571042008447406842365927003964136010900085948470710898215762285707611363240582119229476104939650721699381704941123364811344724592982701830794079598394285146498150830862454334000971277684695435401757578174165958727166015623660193224743868743169794663297551924216693509773157908427355054043577132853500792288268541065995860229716371030156790687127058407753253575399258162145001628070304720512848770014571941910312263708361162921750599521331459106541810986898798211369316535638334255897783293174222672342746614648479227657510647272385373546061481897631235779201853642340

p = pow(c, d, n)

print(p)
# from Crypto.PublicKey import RSA
# from Crypto.Cipher import PKCS1_v1_5
#
# rsa = RSA.construct((n, e, d))
#
# cipher = PKCS1_v1_5.new(rsa) # pub key export for exchange
#
# ciphertext = cipher.encrypt('test'.encode())
# #message to encrypt is in the above line 'encrypt this message'

def i2osp(x, xLen):
    if x >= 256 ** xLen:
        raise ValueError("integer too large")
    digits = []

    while x:
        digits.append(int(x % 256))
        x //= 256
    for i in range(xLen - len(digits)):
        digits.append(0)
    return digits[::-1]


t = [bytes([i]) for i in i2osp(p, 256)]

ans = ''
for i in t:
    ans += i.decode("utf8")

print(ans)
#
# a = bytes.fromhex(hex(c)[2:])
#
# print(cipher.decrypt(a, None))
